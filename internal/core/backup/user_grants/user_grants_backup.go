package user_grants_backup

import (
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"

	"sfDBTools/internal/logger"
	backup_utils "sfDBTools/utils/backup"
)

// UserGrantsBackupResult contains the result of user grants backup
type UserGrantsBackupResult struct {
	OutputFile      string        `json:"output_file"`
	OutputSize      int64         `json:"output_size"`
	Duration        time.Duration `json:"duration"`
	TotalUsers      int           `json:"total_users"`
	BackupTime      time.Time     `json:"backup_time"`
	CompressionUsed bool          `json:"compression_used"`
	EncryptionUsed  bool          `json:"encryption_used"`
}

// BackupUserGrants backs up all user grants to a separate file using SHOW GRANTS method
func BackupUserGrants(options backup_utils.BackupOptions) (*UserGrantsBackupResult, error) {
	lg, _ := logger.Get()

	startTime := time.Now()

	lg.Info("Starting user grants backup",
		logger.String("host", options.Host),
		logger.Int("port", options.Port),
		logger.String("output_dir", options.OutputDir))

	// Generate output filename for user grants
	timestamp := time.Now().Format("20060102_150405")
	baseFilename := fmt.Sprintf("user_grants_%s_%d_%s", options.Host, options.Port, timestamp)

	// Add compression extension if needed
	if options.Compress {
		switch options.Compression {
		case "gzip", "pgzip":
			baseFilename += ".sql.gz"
		case "zlib":
			baseFilename += ".sql.zlib"
		case "zstd":
			baseFilename += ".sql.zst"
		default:
			baseFilename += ".sql.gz"
		}
	} else {
		baseFilename += ".sql"
	}

	// Add encryption extension if needed
	if options.Encrypt {
		baseFilename += ".enc"
	}

	outputFile := filepath.Join(options.OutputDir, "user_grants", baseFilename)

	// Create output directory
	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create output file
	outFile, err := os.Create(outputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to create output file: %w", err)
	}
	defer outFile.Close()

	// Set up writer chain: compression -> encryption -> file
	var writer io.WriteCloser
	var closers []io.Closer

	writer, closers, err = backup_utils.BuildWriterChain(outFile, options, lg)
	if err != nil {
		lg.Error("Failed to set up writer chain", logger.Error(err))
		return nil, err
	}
	defer func() {
		// Close writers in reverse order (inner to outer)
		for i := len(closers) - 1; i >= 0; i-- {
			if err := closers[i].Close(); err != nil {
				lg.Warn("Failed to close writer", logger.Error(err))
			}
		}
	}()

	// Write backup header
	header := fmt.Sprintf(`-- ================================
-- User Grants Backup
-- ================================
-- Host: %s:%d
-- User: %s
-- Backup Time: %s
-- Generated by: sfDBTools
-- ================================

`, options.Host, options.Port, options.User, startTime.Format("2006-01-02 15:04:05"))

	if _, err := writer.Write([]byte(header)); err != nil {
		return nil, fmt.Errorf("failed to write header: %w", err)
	}

	// Execute user grants backup
	totalUsers, err := executeUserGrantsBackup(options, writer)
	if err != nil {
		return nil, fmt.Errorf("failed to backup user grants: %w", err)
	}

	// Close all writers to ensure data is flushed
	for i := len(closers) - 1; i >= 0; i-- {
		if err := closers[i].Close(); err != nil {
			lg.Warn("Failed to close writer", logger.Error(err))
		}
	}

	// Get file size
	fileInfo, err := os.Stat(outputFile)
	if err != nil {
		lg.Warn("Failed to get file info", logger.Error(err))
	}

	duration := time.Since(startTime)

	result := &UserGrantsBackupResult{
		OutputFile:      outputFile,
		OutputSize:      fileInfo.Size(),
		Duration:        duration,
		TotalUsers:      totalUsers,
		BackupTime:      startTime,
		CompressionUsed: options.Compress,
		EncryptionUsed:  options.Encrypt,
	}

	// lg.Info("User grants backup completed successfully",
	// 	logger.String("output_file", result.OutputFile),
	// 	logger.Int64("file_size", result.OutputSize),
	// 	logger.String("duration", result.Duration.String()),
	// 	logger.Int("total_users", result.TotalUsers))

	return result, nil
}

// executeUserGrantsBackup executes the actual user grants backup using SHOW GRANTS method
func executeUserGrantsBackup(options backup_utils.BackupOptions, writer io.Writer) (int, error) {
	lg, _ := logger.Get()

	lg.Info("Executing SHOW GRANTS method for user backup")

	// First query to get all users and generate SHOW GRANTS statements
	getUsersQuery := "SELECT CONCAT('SHOW GRANTS FOR ''',user,'''@''',host,''';') FROM mysql.user WHERE user<>''"

	// Build mysql command for getting users
	getUsersCmd := exec.Command("mysql",
		fmt.Sprintf("--host=%s", options.Host),
		fmt.Sprintf("--port=%d", options.Port),
		fmt.Sprintf("--user=%s", options.User),
		"--skip-column-names",
		"-A",
		"-e", getUsersQuery)

	// Set password environment variable if provided
	if options.Password != "" {
		getUsersCmd.Env = append(os.Environ(), fmt.Sprintf("MYSQL_PWD=%s", options.Password))
	}

	// Get the output of the first command
	showGrantsStatements, err := getUsersCmd.Output()
	if err != nil {
		return 0, fmt.Errorf("failed to get users list: %w", err)
	}

	// Count users for statistics
	userCount := len(strings.Split(strings.TrimSpace(string(showGrantsStatements)), "\n"))
	if string(showGrantsStatements) == "" {
		userCount = 0
	}

	lg.Info("Found users to backup", logger.Int("user_count", userCount))

	// Second command to execute all SHOW GRANTS statements
	executeGrantsCmd := exec.Command("mysql",
		fmt.Sprintf("--host=%s", options.Host),
		fmt.Sprintf("--port=%d", options.Port),
		fmt.Sprintf("--user=%s", options.User),
		"--skip-column-names",
		"-A")

	// Set password environment variable if provided
	if options.Password != "" {
		executeGrantsCmd.Env = append(os.Environ(), fmt.Sprintf("MYSQL_PWD=%s", options.Password))
	}

	// Feed the SHOW GRANTS statements to the second command
	executeGrantsCmd.Stdin = strings.NewReader(string(showGrantsStatements))

	// Get grants output
	grantsOutput, err := executeGrantsCmd.Output()
	if err != nil {
		return 0, fmt.Errorf("failed to execute SHOW GRANTS: %w", err)
	}

	// Process the output and add semicolons
	grants := string(grantsOutput)
	lines := strings.Split(grants, "\n")

	grantStatements := 0
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line != "" {
			if !strings.HasSuffix(line, ";") {
				line += ";"
			}
			if _, err := writer.Write([]byte(line + "\n")); err != nil {
				return 0, fmt.Errorf("failed to write grant statement: %w", err)
			}
			grantStatements++
		}
	}

	// Add FLUSH PRIVILEGES
	if _, err := writer.Write([]byte("\n-- Refresh privileges\nFLUSH PRIVILEGES;\n")); err != nil {
		return 0, fmt.Errorf("failed to write FLUSH PRIVILEGES: %w", err)
	}

	// lg.Info("User grants backup processing completed",
	// 	logger.Int("total_users", userCount),
	// 	logger.Int("grant_statements", grantStatements))

	return userCount, nil
}
